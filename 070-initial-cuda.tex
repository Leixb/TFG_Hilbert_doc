%! TEX root = **/010-main.tex
% vim: spell spelllang=en:

\section{Initial CUDA implementation}

The C implementation was adapted to be run by CUDA. Each CUDA thread will run a
full trajectory to completion and they can all be run in parallel as long as we
don't exceed the GPU threads. For the initial version we implemented the program
to run in a single GPU with a total of 10240 CUDA cores and 12Gb of memory.

Given the results of the convergence analysis from~\cref{sec:convergence}, each
trajectory was computed using RK4 with a step of $\Delta t=10^{-3}$ performing
$10^4$ steps. To save the full trajectory we need $10^4\cdot 8$ bytes (80kb). To
compute 10240 trajectories the total amount of memory needed is around 800Mb
which is feasible. However, we can compute the different metrics to find limit
cycles in place during the integration steps so there is no need to save the
full trajectory (we can just save 8 to 100 bytes of data for each trajectory
depending on the metrics we compute).

Given a pair of axis (delimited $x$ and $y$ ranges) the different points in the
grid were separated into blocks of 32 by 32 points (1024 threads) and ran using
a CUDA kernel that computed the different values wanted for each trajectory. For
this initial version, the divisions on each axis were multiples of 2 and equal
for $x$ and $y$ ($1024\times 1024$, $64\times 64$ \dots ). All the results where
then saved to a file from which they could be extracted easily.

Although we have no problems on the amount of memory needed to save the
information needed, there are limitations in the number of register variables
available to each thread. In this initial version a cache was used to compute
intermediate values which occupied 32 bytes per trajectory. This cache may not
be needed and using registers may give better performance, but the goal of this
initial implementation is to be as close as possible to the original $C$ version
and serve as a baseline of the minimum performance gain using CUDA.

% \begin{verbatim}
% Device 0: "TITAN V"
%   Major revision number:                         7
%   Minor revision number:                         0
%   Total amount of global memory:                 12652838912 bytes
%   Number of multiprocessors:                     80
% MapSMtoCores for SM 7.0 is undefined.  Default to use 128 Cores/SM
%   CUDA Cores/MP:                                 128
% MapSMtoCores for SM 7.0 is undefined.  Default to use 128 Cores/SM
%   Total CUDA Cores                               10240
%   Total amount of constant memory:               65536 bytes
%   Total amount of shared memory per block:       49152 bytes
%   Total number of registers available per block: 65536
%   Warp size:                                     32
%   Maximum number of threads per block:           1024
%   Maximum sizes of each dimension of a block:    1024 x 1024 x 64
%   Maximum sizes of each dimension of a grid:     2147483647 x 65535 x 65535
%   Maximum memory pitch:                          2147483647 bytes
%   Texture alignment:                             512 bytes
%   Clock rate:                                    1.46 GHz
%   Memory Clock rate:                             0.85 GHz
%   Memory Bus Width:                              3072 bits
%   Number of asynchronous engines:                7
%   It can execute multiple kernels concurrently:  Yes
%   Concurrent copy and execution:                 Yes
% \end{verbatim}
